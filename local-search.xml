<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>開學第一週</title>
    <link href="/2022/09/08/20220908/"/>
    <url>/2022/09/08/20220908/</url>
    
    <content type="html"><![CDATA[<hr><p>這週是開學第一週，雖說我這學期的學分比過去少了很多，但我認為反而工作量並沒有減少太多。最近又剛好遇到有學長問我是否有想要實習，是做電腦視覺那方面的，我個人其實還蠻感興趣的，但我非常擔心會因此而拖累到專題的進度，也十分害怕自己會忙不過來而導致其他事情被delay。因此我目前還在觀望，先試試看這陣子是否太忙，之後再來決定。這幾週陸續有推甄的消息出來了，而我的進度仍然還是只完成了個人簡歷，真的不知道自傳到底要寫什麼，好擔心啊。</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>測試模型中...</title>
    <link href="/2022/09/04/20220904/"/>
    <url>/2022/09/04/20220904/</url>
    
    <content type="html"><![CDATA[<hr><p>最近在測試我的模型，我使用了兩種版本，一種是利用Feature Disentanglement的方式，透過將Content與Style分開，之後再將Content image的content feature與Style image的style feature合併。第二種則是透過AdaIN，將Content image去風格化後再將style的風格加在上面。雖說兩者的概念上是類似的，但實際在寫時所用的方法差蠻多的(之後有空再來介紹AdaIN)。這週與老師meeting時老師也提到我怎麼用的方法兩週內差那麼多XD，其實是我自己不小心把第一種方法寫壞了，以為我的模型可能不適合跑大資料集(事實證明我錯了，可以看「模型train不起來」這篇)。而兩種模型跑出來有一些微妙的差異，各有好壞，但第一種模型的缺點也很明顯，有時會合成的image中會有Style image裡面特徵，而那個特徵並沒有很好的融合在圖片中，反而會使圖片看起來就像是有雜訊一樣。等之後的模型全部train完再來看一下結果如何ㄌ～</p><hr>]]></content>
    
    
    <categories>
      
      <category>學習紀錄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度學習</tag>
      
      <tag>畢業專題</tag>
      
      <tag>Autoencoder</tag>
      
      <tag>Style Transfer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新生訓練</title>
    <link href="/2022/09/02/20220902/"/>
    <url>/2022/09/02/20220902/</url>
    
    <content type="html"><![CDATA[<hr><p>今天被學生會邀請回去介紹CPC社團，原本2:20就準備要換我講了，但中間發生一些事，且中間又臨時加了理工學院院院長的介紹，我覺得院長非常健談，只用一頁投影片就講了好久哈哈哈XD。之後換到我，我就先在乙班先介紹，中間都還算順利，而到甲班後，由於我們社團的指導老師剛好是甲班班導，老師就剛好坐在後面，導致我覺得我講的綁手綁腳的。這次新生訓練讓我深深感受到，我在輔大的時間只剩下不到一年了，再過個幾年我就要出社會了，目前的我還實在不知道要如何面對這件事情，只能走一步算一步了。</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa10931 Parity</title>
    <link href="/2022/08/30/20220830/"/>
    <url>/2022/08/30/20220830/</url>
    
    <content type="html"><![CDATA[<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1872">題目連結</a></p><hr><ul><li>❗️ 題意<br>給定數字n，請求出n這個數字的二進位為何與它的二進位數字有幾個1</li></ul><hr><ul><li>✔️ 題解<br>我們可以直接利用模擬的方式，每次就是先看這個數字除以2的餘數為何，之後再除以2就好，在過程中當餘數為1時可以紀錄下來，就是二進位數字中共有多少一。</li></ul><hr><ul><li>💻 程式碼<blockquote><p>10ms</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> num;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; num &amp;&amp; num != <span class="hljs-number">0</span>)&#123;<br>string st;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>st += <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cnt++;<br>st +=<span class="hljs-string">&#x27;1&#x27;</span>;<br>&#125;<br>num /= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-built_in">reverse</span>(st.<span class="hljs-built_in">begin</span>(), st.<span class="hljs-built_in">end</span>());<br>cout &lt;&lt; <span class="hljs-string">&quot;The parity of &quot;</span> &lt;&lt; st &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot; (mod 2).\n&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以利用python的bin來簡化程式碼</p><blockquote><p>10ms</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>:<br><span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;The parity of <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(num))[<span class="hljs-number">2</span>:]&#125;</span> is <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(num)).count(<span class="hljs-string">&quot;1&quot;</span>)&#125;</span> (mod 2).&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><ul><li>🧠 心得<br>自從開始做畢業專題後寫python的時間比寫c++的時間多太多了，程式語言就是個工具，不同場合需要使用的語言本來就不同，對我來說c++多半是拿來解題較多，而其他時間多是使用python。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>UVa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>binary</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa10721 Bar Codes</title>
    <link href="/2022/08/28/20220828/"/>
    <url>/2022/08/28/20220828/</url>
    
    <content type="html"><![CDATA[<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1662">題目連結</a></p><hr><ul><li>❗️ 題意<br>bar codes是由黑色與白色的線組合而成，給定n, k, m，分別代表共有n條線，k個bar(分為黑色區域與白色區域，且必定黑白相間，一開始為黑色區域)，每個bar最多由m條線組成，請求給定條件下的所有可能數量。</li></ul><hr><ul><li>✔️ 題解<br>再開始題解前，我可以先來思考一個問題</li><li>舉個例子：假設我們有無限個1元、2元、3元的硬幣，共有幾種方法可以組合出5元?<ul><li>Ans:5(11111, 1112, 113, 122, 23)</li></ul></li><li>但其實我們可以透過轉換這個問題為求可能的方法數，變成$(1+x+x^2+x^3+x^4+x^5+..)(1+x^2+x^4+..)(1+x^3+x^6+..)&#x3D;a_0+a_1x+a_2x^2+…$的解中$x^5$的係數。且由於三個括號中只要x的次方大於5就不會影響到$x^5$的答案，因此我們可以省略成$(1+x+x^2+x^3+x^4+x^5)(1+x^2+x^4)(1+x^3)&#x3D;a_0+a_1x+a_2x^2+…$，而這個多項式$x^5$的係數為5，也與我們的答案是一樣的。(<a href="https://stat.nuk.edu.tw/cbme/discrete/disc_math/ch4.pdf">更多詳細內容可以參考這裡</a>)</li><li>生成函數到底與這題有什麼關係呢？其實我們可以想像區間其實就是上面例子中的無限個1元，而最高次其實就是m，並且由於我們的區間至少要有一個，所以並沒有常數項。因此此題就變成了：<br>$(x+x^2+x^3+..+x^m)^k &#x3D; a_0x^k+a_1x^{k+1}+a_2x^{k+2}+..$在$x^n$的係數為何?我們還可以將x項提出來，變成$x^k(1+x+x^2+..+x^{m - 1})^k &#x3D; x^k(a_0+a_1x+a_2x^2+…)$，並左右同除以$x^k$，最後就得到了$(1+x+x^2+..+x^{m - 1})^k &#x3D; (a_0+a_1x+a_2x^2+…)$，而我們就變成求$x^{n-k}$的係數了。</li></ul><hr><ul><li>💻 程式碼<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function">vector&lt;LL&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;LL&gt; v, vector&lt;LL&gt; base)</span></span>&#123;<br><span class="hljs-function">vector&lt;LL&gt; <span class="hljs-title">ans</span><span class="hljs-params">((<span class="hljs-type">int</span>)v.size() + (<span class="hljs-type">int</span>)base.size() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>(); i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-type">int</span>)base.<span class="hljs-built_in">size</span>(); j++)&#123;<br>ans[i + j] += v[i] * base[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n, k, m;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; k &gt;&gt; m)&#123;<br><span class="hljs-keyword">if</span>(k * m &lt; n || n &lt; k)&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>vector&lt;LL&gt;<span class="hljs-built_in">v</span>(m, <span class="hljs-number">1</span>);<br>vector&lt;LL&gt;<span class="hljs-built_in">base</span>(m, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++)&#123;<br>v = <span class="hljs-built_in">mul</span>(v, base);<br>&#125;<br>cout &lt;&lt; v[n - k] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>當bar的最長線條數乘以bar的數量小於線條的數量或者線條的數量小於bar的數量都是0</p>          </div></li></ul><hr><ul><li>🧠 心得<br>這題大部分的做法都是利用DP的方式來做，連老師介紹這題時也是利用DP。但有一位非常厲害的同學給了給了利用生成函數的想法(在此請收下我的膝蓋🧎‍♂️)，而我也應證了此想法是正確的。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>UVa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>Generating Function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型train不起來</title>
    <link href="/2022/08/25/20220825/"/>
    <url>/2022/08/25/20220825/</url>
    
    <content type="html"><![CDATA[<hr><p>這禮拜算是遇到了一些低潮，由於資源實在不太夠了，目前我一個人所使用GPU的ram至少需要36G左右，又加上我是一次跑很多個小模型(不同風格需要分開train)，目前的GPU是兩張3090，仍然不夠我們用，只能Deep Learning真的都是用錢燒出來的哈哈哈哈。<br>而另一點是我找到了一個5000張content與5000張style的dataset，我的模型對於還原content與style雖然有些模糊，但還算可以接受，至於他們所組合出來的合成照就是灰灰的一片，目前我認為可能有兩種原因，第一種純粹是還沒train完(大約只跑了2%左右)，再來就是我的模型餐數量太少了，沒有辦法完全學習好。我自己還不知道要怎麼解決。我個人是傾向第二種，因此只好先想辦法再拿更小的資料集來印證我的想法。最近也會盡量多找一些paper來看，希望能找到一些修改上的靈感。</p><hr>]]></content>
    
    
    <categories>
      
      <category>學習紀錄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>深度學習</tag>
      
      <tag>畢業專題</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CycleGAN</title>
    <link href="/2022/08/23/20220823/"/>
    <url>/2022/08/23/20220823/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="CycleGAN"><a href="#CycleGAN" class="headerlink" title="CycleGAN"></a><a href="https://arxiv.org/pdf/1703.10593.pdf">CycleGAN</a></h1><p><img src="/./img/20220823/first_page.png"></p><hr><h2 id="📝-背景知識"><a href="#📝-背景知識" class="headerlink" title="📝 背景知識"></a>📝 背景知識</h2><ul><li>Generative Adversarial Networks</li></ul><hr><h2 id="❗️-Introduction"><a href="#❗️-Introduction" class="headerlink" title="❗️ Introduction"></a>❗️ Introduction</h2><p>成對的資料是非常難以搜集的(有點像監督式學習的方式，可以參考pix2pix)，而CycleGAN只需要兩個domain的資料(例如一群馬的data與一群斑馬的data)，就可以完成兩個domain內的互相轉換，這不僅降低了資料搜集的難度，也增廣了能應用的層面。<br><img src="/./img/20220823/pair.png" alt="paired data v.s unpaired data"></p><hr><h2 id="🏆-Goal"><a href="#🏆-Goal" class="headerlink" title="🏆 Goal"></a>🏆 Goal</h2><ul><li>Generator<ul><li>我們以馬與斑馬作為例子，假設他們的資料及分別稱為$X$與$Y$，那我們要做的事情就是訓練兩個Generator$G$與$F$，我們希望 $X$經過 $G$後盡可能與$Y$越像越好，且$Y$經過$F$後也要可能與$X$越像越好。寫成數學一點就是$G(x)\approx y$，且$F(y)\approx x$ ($x \in X$ and $y \in Y$)。</li></ul></li><li>Discriminator<ul><li>要如何衡量生成器的好壞，就輪到我們的Discriminator出場啦，我們一樣有兩個Discrminator $D_X$與$D_Y$，分別是判斷$F(y)$與$x$是否足夠相似與$G(x)$與$y$是否足夠相似，其實就有點像是在train一個classifier的感覺，因此整體的架構如下：</li><li><img src="/./img/20220823/structure.png" alt="架構"></li></ul></li><li>Loss Function<ul><li>Adversarial Loss<ul><li>$\mathcal{L}_{GAN}(G, D_Y, X, Y) &#x3D; \mathbb{E} _{p \sim data(y)}[\log (D_Y(y))] + \mathbb{E} _{p \sim data(x)}[\log (1 - D_Y(G(x)))] $</li><li>我們以$G$(使x mapping to y)與$D_Y$(分辨$G(x)$與$y$)作為例子，這個loss的主要功用就是讓最的$G(x)$與$y$越像好，對於Generator來說，我們會希望去minimize這個loss，而Discrminator則是相反，希望去maximize這個loss，對於$F$與$D_X$也是一樣的。</li></ul></li><li>Cycle Consistency Loss<ul><li>$\mathcal{L}_{cyc}(G, F) &#x3D; \mathbb{E} _{p \sim data(x)}[||F(G(x)) - x||_1] + \mathbb{E} _{p \sim data(y)}[||G(F(y)) - y||_1]$</li><li>單單只有Adversarial Loss是無法讓整個model有好效果的，因為我們無法確定$x$與$G(x)$是否足夠類似，因此我們需要利用來回映射(以馬為例子就是：馬➡️斑馬➡️馬)，也就是希望讓$x$與$F(G(x))$越像越好。<div class="note note-warning">            <p>作者在論文中有提到，相較起來L1的效果是最好的</p>          </div></li></ul></li><li>Identity Loss(optional)<ul><li>$\mathcal{L}_{identity}(G, F) &#x3D; \mathbb{E} _{p \sim data(y)}[||G(y) - y||_1] + \mathbb{E} _{p \sim data(x)}[||F(x) - x||_1]$</li><li>這個loss作者只簡單地提及了一下，但它也是一個非常重要的loss。我們知道$G$是用來生成斑馬的Generator，因此若我們將斑馬$y$丟進這個Generator後，出來的結果也應該是斑馬，因此這個loss就是在最小化這件事。<div class="note note-danger">            <p>當初我在報這篇論文給教授聽時報告錯這個部分，真尷尬：）</p>          </div></li></ul></li></ul></li></ul><hr><h2 id="🍎-Result"><a href="#🍎-Result" class="headerlink" title="🍎 Result"></a>🍎 Result</h2><p><img src="/./img/20220823/result.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa00524 Prime Ring Problem</title>
    <link href="/2022/08/21/20220821/"/>
    <url>/2022/08/21/20220821/</url>
    
    <content type="html"><![CDATA[<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=465">題目連結</a></p><hr><ul><li>❗️ 題意<br>給定數字n，代表利用1~n的數字圍成一個環，並以1當成出發點，連續的數字加起來一定要是質數(包括最後一個數字與1)，請輸出所以可能的組合。</li></ul><hr><ul><li>✔️ 題解<br>很明顯這題就是枚舉，我們只先建出一個質數表，只要建到31即可(n最大16，其中最大的質數就是15+16&#x3D;31)，我們再利用backtracking的方式，維護一個vector，當目前的最後一個與要新加入的數字和為質數時就將其加入，並在當vector的長度為n時，確認最後一個與第一個數字的和是否是質數，再決定是否是合法的序列。<br>其中，我們可以注意到，因為我們組出來的序列一定會是「奇偶奇偶奇偶奇偶…」，若n是奇數時，最後一個數字一定也會是奇數，結尾的奇數(至少3)加開頭的1一定是一個大於2的偶數，而大於2的偶數都不是質數，也就是說我們沒有辦法組合出任何一個序列，因此當n是奇數時是沒有答案的。</li></ul><hr><ul><li>💻 程式碼<blockquote><p>160ms</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">prime_table</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">35</span>, <span class="hljs-literal">true</span>)</span></span>;<br>p[<span class="hljs-number">0</span>] = p[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">35</span>; i++)&#123;<br><span class="hljs-keyword">if</span>(p[i])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * i; j &lt; <span class="hljs-number">35</span>; j += i)&#123;<br>p[j] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-type">bool</span> used[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> n;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>vector&lt;<span class="hljs-type">bool</span>&gt;p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(v.<span class="hljs-built_in">size</span>() == n &amp;&amp; p[v.<span class="hljs-built_in">back</span>() + <span class="hljs-number">1</span>])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)<br>cout &lt;&lt; v[i];<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; v[i];<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br><span class="hljs-keyword">if</span>(!used[i])&#123;<br><span class="hljs-keyword">if</span>(p[v[v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] + i])&#123;<br>v.<span class="hljs-built_in">emplace_back</span>(i);<br>used[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>();<br>v.<span class="hljs-built_in">pop_back</span>();<br>used[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>p = <span class="hljs-built_in">prime_table</span>();<br><span class="hljs-type">int</span> kase = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; n)&#123;<br><span class="hljs-built_in">memset</span>(used, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(used));<br>v.<span class="hljs-built_in">clear</span>();<br>v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>);<br>used[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(kase)<br>cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Case &quot;</span> &lt;&lt; ++kase &lt;&lt; <span class="hljs-string">&quot;:\n&quot;</span>;<br><span class="hljs-keyword">if</span>((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">dfs</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>在題目上沒提到連續兩個case間要換行🤔</p>          </div></li></ul><hr><ul><li>🧠 心得<br>昨天社團請了外部講師來講數論這個主題，講到後來我真的差點瘋了，後半部分真的完全聽不懂，有一半時間都在看著投影片發呆，剛好我又坐在最前面，超級尷尬的。高中時我一直自認為數學還不錯，上了大學後才發現自己的數學其實根本就不太好QQ，要多加油了～</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>UVa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>Backtracking</tag>
      
      <tag>Prime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你現在過得好嗎</title>
    <link href="/2022/08/20/20220820/"/>
    <url>/2022/08/20/20220820/</url>
    
    <content type="html"><![CDATA[<hr><p>Juby是曾經我家養的一隻狗狗，是我最好的家人跟朋友，它在去年的8月19號凌晨離開我了，那天也剛好是我去比私立大專院校程式競賽的日子。其實在他過世的前幾天我就有感覺他準備要離開我們了，完全不吃飯，一直拉肚子，連站起來的力氣都幾乎沒了。我能感受到，他應該也非常的害怕，我只能抱著他，安慰他，讓他知道我永遠都會在他的身邊。</p><p>Juby過世的當下，是我第一次感受到如此的心痛與不捨，彷彿我的心也在當下支離破脆的一般。從到過世到現在，已經過了一年了，我仍會回憶起Juby還在時的場景，想起他陪伴我的每個瞬間，想起他的一舉一動是如何讓人好氣又好笑。而如今的我，只能看著過去的照片，想像著他還在我們的身邊。</p><p>不知道Juby你現在，過得還好嗎？<br>我們都很想你，真的很想你。</p><table><thead><tr><th align="center">狗鄙視</th><th align="center">me &amp; Juby</th><th align="center">Juby伸懶腰</th></tr></thead><tbody><tr><td align="center"><img src="/./img/20220820/1.png"></td><td align="center"><img src="/./img/20220820/2.png"></td><td align="center"><img src="/./img/20220820/3.jpeg"></td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>父親節快樂</title>
    <link href="/2022/08/18/20220818/"/>
    <url>/2022/08/18/20220818/</url>
    
    <content type="html"><![CDATA[<hr><p>我爸是一間小公司的老闆，說是老闆，其實大部分的事情也都是我爸一個人在處理，包括接案子時要的任何單據，全部都是他用一台將近10年前，開word會當機的電腦一個鍵一個鍵打出來的。對我來說，我覺得蠻簡單的東西，我爸卻要花超過10倍的時間才能處理好，甚至忙到半夜三四點才睡，早上六點就又出門上班了。<br>昨天晚上，我與我媽一起去挑了一台新的筆電給我爸爸，我也把他平常會用的工具都準備在電腦裡面，給他當成父親節禮物。我爸收到時表面上看起來並沒有特別的情緒起伏，但我想他心中是開心的。<br>老實說我已經有好多年沒有跟爸爸說過父親節快樂了，對於過父親節這整件事對我來說非常尷尬。<br>總而言之，祝您父親節快樂，爸爸! </p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa01001 Say Cheese</title>
    <link href="/2022/08/15/20220815/"/>
    <url>/2022/08/15/20220815/</url>
    
    <content type="html"><![CDATA[<hr><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3442">題目連結</a></p><hr><ul><li>❗️ 題意<br>在一塊起司中，給有n個球形的洞，在洞裡的移動不耗時間，再給定出發點與終點，問你從出發點到終點，的最短路徑(距離：時間 &#x3D; 1:10)是多少?</li></ul><hr><ul><li>✔️ 題解<br>將起點與終點的半徑設為0(變成半徑為0的球)，再將所有球的考慮過半徑的距離算出來，做一次Floyd Warshall就可找出起點到終點的最短路徑(時間)。<br>假設有點A與點B，A(x)代表A的座標在x，r則是其半徑，我們可以分成以下三個case來討論：<table><thead><tr><th align="center">Case1:兩圓外離</th><th align="center">Case2:兩圓外切</th><th align="center">Case3:兩圓相交</th></tr></thead><tbody><tr><td align="center"><img src="/./img/20220815/case1.png"></td><td align="center"><img src="/./img/20220815/case2.png"></td><td align="center"><img src="/./img/20220815/case3.png"></td></tr></tbody></table></li></ul><p>因此，我們可以導出以下式子<br>$$<br>distance(a, b) &#x3D;<br>\begin{cases}<br>\overline{AB} - r_{a} - r_{b}, &amp; \text{if $\overline{AB}$ &gt; $r_{a}$ + $r_{b}$} \\<br>0, &amp; \text{if $\overline{AB}$ $\le$  $r_{a}$ + $r_{b}$}<br>\end{cases}<br>$$<br>建完圖後這題就變成單純的最短路啦，我們只要利用floyd warshall或任何求最短路的演算法，找出起點與終點的距離再乘以10就是答案了。</p><hr><ul><li>💻 程式碼<blockquote><p>10ms</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis_cal</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> z1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> z2)</span></span>&#123;<br><span class="hljs-type">double</span> x = x1 - x2, y = y1 - y2, z = z1 - z2;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(x * x + y * y + z * z);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">holes</span>&#123;<br><span class="hljs-type">int</span> x, y, z, r;<br>&#125;;<br><br>holes arr[<span class="hljs-number">105</span>];<br><span class="hljs-type">double</span> dis[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> kase = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>cin &gt;&gt; arr[i].x &gt;&gt; arr[i].y &gt;&gt; arr[i].z &gt;&gt; arr[i].r;<br>&#125;<br><span class="hljs-comment">// 起點與終點可以視為半徑=0的洞</span><br>cin &gt;&gt; arr[<span class="hljs-number">0</span>].x &gt;&gt; arr[<span class="hljs-number">0</span>].y &gt;&gt; arr[<span class="hljs-number">0</span>].z;<br>arr[<span class="hljs-number">0</span>].r = <span class="hljs-number">0</span>;<br>cin &gt;&gt; arr[n + <span class="hljs-number">1</span>].x &gt;&gt; arr[n + <span class="hljs-number">1</span>].y &gt;&gt; arr[n + <span class="hljs-number">1</span>].z;<br>arr[n + <span class="hljs-number">1</span>].r = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n + <span class="hljs-number">2</span>; j++)&#123;<br>dis[i][j] = INT_MAX;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 利用公式，紀錄任兩點的距離。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n + <span class="hljs-number">2</span>; j++)&#123;<br><span class="hljs-type">double</span> d = <span class="hljs-built_in">dis_cal</span>(arr[i].x, arr[i].y, arr[i].z, arr[j].x, arr[j].y, arr[j].z);<br><span class="hljs-keyword">if</span>(d &lt;= arr[i].r + arr[j].r)<br>dis[i][j] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span>&#123;<br>dis[i][j] = d - arr[i].r - arr[j].r;<br>&#125;<br><br>&#125;<br>&#125;<br><span class="hljs-comment">// floyd warshall</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n + <span class="hljs-number">2</span>; k++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n + <span class="hljs-number">2</span>; j++)&#123;<br>dis[i][j] = <span class="hljs-built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cheese %d: Travel time = %d sec\n&quot;</span>, ++kase, (<span class="hljs-type">int</span>)<span class="hljs-built_in">round</span>(dis[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>] * <span class="hljs-number">10</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>答案記得乘以10後做round，否則會有精度問題QQ</p>          </div></li></ul><hr><ul><li>🧠 心得<br>記得這是某次我們學校自辦賽的題目，當初做完這題的時候一直WA，找不到自己哪裡寫錯了，想說是哪裡想法有錯，最後被精度搞了一波🥲。<br>賽後發現自己的想法是正確的，只差在取round的部分，就想在這邊分享給大家啦～</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>UVa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Floyd Warshall</tag>
      
      <tag>Shortest Path</tag>
      
      <tag>Graph</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa00452 Project Scheduling</title>
    <link href="/2022/08/13/20220813/"/>
    <url>/2022/08/13/20220813/</url>
    
    <content type="html"><![CDATA[<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=393">題目連結</a></p><hr><ul><li>❗️ 題意<br>給定點、經過這個點的cost、哪些點連到這個點，求出需要多少時間才能夠走完所有點。</li></ul><hr><ul><li>✔️ 題解<br>ans[now]代表目前這個點的答案，而ans[next]是now這個點所可以走到的點，而更新公式就是ans[next] &#x3D; max(ans[next], node[next] + ans[now])，其中node是原本點上的值。<br>我們只需要在利用BFS做拓墣排序的過程中更新ans的值，就能夠確定點的更新順序是對的，不會有更新點的時候前面的點還沒有更新到的問題，最後只需要輸出最大的ans[i]即可。</li></ul><hr><ul><li>💻 程式碼<blockquote><p>140ms</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> node[MAXN];<br><span class="hljs-type">int</span> cnt[MAXN];<br><span class="hljs-type">int</span> ans[MAXN];<br><span class="hljs-type">bool</span> used[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt;G[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(node, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(node));<br><span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br><span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(ans));<br><span class="hljs-built_in">memset</span>(used, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(used));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXN; i++)&#123;<br>G[i].<span class="hljs-built_in">clear</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> t;<br>string line;<br>cin &gt;&gt; t;<br>cin.<span class="hljs-built_in">ignore</span>();<br><span class="hljs-built_in">getline</span>(cin, line);<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>line.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">getline</span>(cin, line);<br><span class="hljs-keyword">if</span>(line.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br><span class="hljs-type">char</span> idx, another;<br><span class="hljs-type">int</span> val;<br>ss &gt;&gt; idx;<br>ss &gt;&gt; val;<br>node[idx - <span class="hljs-string">&#x27;A&#x27;</span>] = val;<br>ans[idx - <span class="hljs-string">&#x27;A&#x27;</span>] = val;<br>used[idx - <span class="hljs-string">&#x27;A&#x27;</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(ss &gt;&gt; another)&#123;<br>cnt[idx - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>G[another - <span class="hljs-string">&#x27;A&#x27;</span>].<span class="hljs-built_in">emplace_back</span>(idx - <span class="hljs-string">&#x27;A&#x27;</span>);<br>&#125;<br>&#125;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXN; i++)&#123;<br><span class="hljs-keyword">if</span>(cnt[i] == <span class="hljs-number">0</span> &amp;&amp; used[i])&#123;<br>q.<span class="hljs-built_in">emplace</span>(i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> now = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> next: G[now])&#123;<br>ans[next] = <span class="hljs-built_in">max</span>(ans[next], node[next] + ans[now]);<br>cnt[next]--;<br><span class="hljs-keyword">if</span>(cnt[next] == <span class="hljs-number">0</span>)&#123;<br>q.<span class="hljs-built_in">emplace</span>(next);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXN; i++)&#123;<br>res = <span class="hljs-built_in">max</span>(res, ans[i]);<br>&#125;<br>cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">if</span>(t)&#123;<br>cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>這題更煩的反而是格式輸入輸出吧…😅</p>          </div></li></ul><hr><ul><li>🧠 心得<br>當初會解這題是因為剛好有學長來問我類似的題目，也趁這次機會來複習一下拓墣排序。之前的我都是用DFS的順序來找order，而改用queue的方法只需要用一個array來記錄入in degree即可，比我用DFS的做法好寫很多。<br>順帶一提，學長說這是他們進碩班老師拿給他們練習的大一題目，大一就在拓墣排序，沒搞錯吧？</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>UVa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Graph</tag>
      
      <tag>cpp</tag>
      
      <tag>Topological Sort</tag>
      
      <tag>AOE Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>忘記要報告了QQ</title>
    <link href="/2022/08/11/20220811/"/>
    <url>/2022/08/11/20220811/</url>
    
    <content type="html"><![CDATA[<hr><p>又到了每週一次的meeting，由於上禮拜沒有meeting到，我以為這週是不用報告的，只要大略講一下這週的進度，就沒有做投影片了。誰知道原來上週我們這組沒有報告到，我就緊急的在其他同學報告的時候把投影片趕出來(只做了7頁)，只能說我真的做的很敷衍哈哈哈。我發現自己常常會有這種僥倖的心態，常常把事情拖到最後一刻才做，我想這點是我需要好好反省並改善的，這幾天我應該會開始做我研究所的讀書計畫，也要開始寄信給老師詢問推薦信的事了，現在只希望一切順利！</p><blockquote><p>30分鐘趕出來的投影片<br><img src="/./img/20220811/20220811.png" alt="敷衍ㄉ投影片"></p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>畢業專題</tag>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型修改</title>
    <link href="/2022/08/10/20220810/"/>
    <url>/2022/08/10/20220810/</url>
    
    <content type="html"><![CDATA[<hr><p>這個星期我稍微修改了模型的架構，聽從了學長的建議，只轉單一風格或許會讓NN學不到「風格」的特徵，因此我應該更注重的是在多種風格的轉換而非單純的多張照片對一種風格的轉換。另外，我也稍微看了一下adain的論文，既然風格轉換可以說是從一個domain映射到另一個domain，那對於最後要生成圖像的decoder(Generator)，就不應該對它做IN(instance normalization)，有關於adain我想我未來可以再發一篇文來解釋。而都是基於理論上的想法，而我在實作時明顯發現，刪掉了IN會讓我的loss能夠將的更低，但由於訓練時間因為要做多風格轉換就從原本的幾個小時變成了需要訓練一天半左右。</p><p>目前訓練上最麻煩的就是時間了，因為每個禮拜都要meeting，但礙於訓練時間拉長的緣故，其實我進度可能會稍微緩慢一些，更何況這還只是對於小資料集(10張照片轉換成8種風格)，未來若要做到更大的資料集，我想那個訓練時間應該會非常可觀QQ，目前也只能這樣了。</p><blockquote><p>未來我在想，應該要增加我的發文頻率，由於我原本預期是週記，但我發現一週能講的事情實在是太多了，而且我是個非常健忘的人，常常一週過了我就忘記我這週到底都在幹嘛了哈哈哈哈，未來我希望能夠一週發個4~5篇文，最好是能每天都更新，不然到最後我怕因為懶惰而放棄我的週記計畫QQ。</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>學習紀錄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度學習</tag>
      
      <tag>畢業專題</tag>
      
      <tag>Autoencoder</tag>
      
      <tag>Style Transfer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七夕情人節快樂</title>
    <link href="/2022/08/08/20220808/"/>
    <url>/2022/08/08/20220808/</url>
    
    <content type="html"><![CDATA[<hr><p>上週四剛好是七夕情人節，而那天我也決定到新竹的清華大學走走(抱歉ㄌ教授，沒有開到每週一次的meeting)，順便看一下他們校園內的設備之類的。雖然沒有辦法進入他們的資工系大樓內，但依然可以看出他們的設備與輔大的差別，光是圖書館就足以讓人羨慕不已(雖然資工學生應該也不會去圖書館啦哈哈哈)，而這也讓我更想上好一點的研究所，卻也因此更加擔憂，害怕自己推甄沒有辦法上。</p><p>這幾天我也在查詢各校資工系的簡章，也開始著手準備自己的履歷。我認為自己的經歷並不豐富，而目前專題也沒有辦法做出一個好的成果，真的只能加油ㄌQQ。</p><p>順帶一提，這週也剛好找到新社長了！未來我就是CPC的退休老人啦，學弟妹加油ㄌ &gt;&lt;</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的吉娃娃著火了</title>
    <link href="/2022/08/03/20220803/"/>
    <url>/2022/08/03/20220803/</url>
    
    <content type="html"><![CDATA[<hr><p>目前我畢業專題研究的主題是Style Transfer，而Style Transfer簡單來說就是將相片A轉換成相片B的風格(曾經被女友說過就是IG特效，差點哭出來QQ)，能使用的方法其實蠻多元的，也不限於使用NN(neural network)來做。而我的整體架構是利用autoencoder的概念，想法算是蠻簡單的，就是將兩張照片的內容與風格抽出來後再合併，比較難的是要如何<strong>「衡量」</strong>一張照片的風格究竟是什麼，對於從小到大都沒有藝術細胞的我來說這真的是非常痛苦的一件事。<br>目前為止整體轉換的效果其實還蠻普通的，可能還需要再調整一下網路架構與想法，下面是我最近做出來的成果，分別是轉變幅度從小到大，而內容都是吉娃娃加上火焰的樣子。</p><table><thead><tr><th align="center">small</th><th align="center">medium</th><th align="center">large</th></tr></thead><tbody><tr><td align="center"><img src="/./img/20220803/small3.png"></td><td align="center"><img src="/./img/20220803/medium3.png"></td><td align="center"><img src="/./img/20220803/large3.png"></td></tr></tbody></table><p>我個人認為中間那張轉換的幅度是最剛好的，而我也試過拿其他風格來轉換，只能說轉換成火焰是一個較為簡單的task，如果是其他風格的話目前我的模型還沒有辦法跑出比較好的結果，只能等調整過再分享給大家。</p><blockquote><p>對了，我的文章下方有開啟留言板，若有建議或任何問題在底下留言，之後再發一篇文來介紹一下我自己好了～</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>學習紀錄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度學習</tag>
      
      <tag>畢業專題</tag>
      
      <tag>Autoencoder</tag>
      
      <tag>Style Transfer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>週記計畫</title>
    <link href="/2022/08/01/20220801/"/>
    <url>/2022/08/01/20220801/</url>
    
    <content type="html"><![CDATA[<hr><p>我是輔大資工要升大四的學生，今天是8月的第一天，也是我開始寫週記的第一週，希望我能夠持續維持記錄生活的習慣。<br>基本上我的週記會包含我的生活與一些心情跟最近在做的事。至於為何要開始寫週記呢，其實我還沒有一個特別好的說法，就只是單純想試試看而已。</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
