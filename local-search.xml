<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode 1239 Maximum Length of a Concatenated String with Unique Characters</title>
    <link href="/2024/01/23/20240123/"/>
    <url>/2024/01/23/20240123/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">題目連結</a></p><hr><h2 id="❗️-題意"><a href="#❗️-題意" class="headerlink" title="❗️ 題意"></a>❗️ 題意</h2><p>給定一個字串陣列 $arr$，請你從裡面取出一些字串並將其連接起來，要保證不能出現重複的字元，請輸出所有可能的結果中長度最長為何?</p><ul><li><p>Input: $arr &#x3D; $ [“un”, “iq”,“ue”]</p></li><li><p>Output: $4$</p><ul><li>“ ”, “un”, “iq”, “ue”, “uniq”, “ique”</li><li>長度最長的為 “uniq” 與 “ique”，兩者皆為4</li></ul></li><li><p>Constraints:</p><ul><li>$1 \leq arr.length \leq 16$</li><li>$1 \leq arr[i].length \leq 26$<ul><li>$arr[i]$ contains only lowercase English letters.</li></ul></li></ul></li></ul><hr><h2 id="✔️-題解"><a href="#✔️-題解" class="headerlink" title="✔️ 題解"></a>✔️ 題解</h2><p>對於此題，由於其陣列長度與其中的字串長度皆不大，因此我們可以很直覺的想到或許可以透過枚舉的方式來解決，因此我在一開始是使用bitmask來枚舉，假設我們現在有一個長度是4的陣列，而bitmask現在是1011，就代表我們要拿第一個，第三個，第四個來計算其連接起來後的結果，而我們只需要透過枚舉0000 ~ 1111，也就是16(1&lt;&lt;4)種情況，就可以將所有可能的情況皆枚舉出來，這種做法由於是將所有可能皆嘗試一次，因此只適用於輸入的陣列不要太大的情況，以此題來說陣列大小最大只有16而已，因此此做法是可以成功AC的，但其效率並不好。</p><p>因此我們可以進一步思考，其實很多結果根本不需要嘗試，假設1100就已經違反規定，那其他的例如1101, 1110, 1111根本沒有試的必要，因此我們可以使用 Backtracking 的方式，只對還沒有違反規定的結果來去枚舉下一步，透過這種剪枝的方式，就能大幅度的減少所需要枚舉的次數。</p><hr><h2 id="💻-程式碼"><a href="#💻-程式碼" class="headerlink" title="💻 程式碼"></a>💻 程式碼</h2><ul><li><p>Bit Mask</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 570 ms, AC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt;now;<br>    <span class="hljs-type">int</span> used[<span class="hljs-number">30</span>];<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">bool</span> alpha[<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> st: now)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s: st)&#123;<br>                <span class="hljs-keyword">if</span>(alpha[s - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">true</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>                &#125;<br>                alpha[s - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;<br>                tot++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tot;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(vector&lt;string&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; arr.<span class="hljs-built_in">size</span>()); i++)&#123;<br>            now.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>((i &gt;&gt; j) &amp; <span class="hljs-number">1</span>)&#123;<br>                    now.<span class="hljs-built_in">emplace_back</span>(arr[j]);<br>                &#125;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">check</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>Backtracking</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 21ms, AC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt;now;<br>    <span class="hljs-type">int</span> used[<span class="hljs-number">30</span>];<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">bool</span> alpha[<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> st: now)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s: st)&#123;<br>                <span class="hljs-keyword">if</span>(alpha[s - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">true</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>                &#125;<br>                alpha[s - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;<br>                tot++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tot;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, vector&lt;string&gt;&amp; arr)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx + <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(!used[i])&#123;<br>                now.<span class="hljs-built_in">emplace_back</span>(arr[i]);<br>                <span class="hljs-type">int</span> chk = <span class="hljs-built_in">check</span>();<br>                <span class="hljs-keyword">if</span>(chk != <span class="hljs-number">-1</span>)&#123;<br>                    used[i] = <span class="hljs-literal">true</span>;<br>                    ans = <span class="hljs-built_in">max</span>(ans, chk);<br>                    <span class="hljs-built_in">dfs</span>(i, arr);<br>                &#125;<br>                now.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(vector&lt;string&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">-1</span>, arr);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>Runtime: 21 ms, faster than 72.91% of C++ online submissions</p>          </div></li></ul><hr><h2 id="🧠-心得"><a href="#🧠-心得" class="headerlink" title="🧠 心得"></a>🧠 心得</h2><p>我覺得的我的 check function並沒有寫好， 因為我每次計算時都要重新計算一次長度，但其實不需要這樣做，我們可以維護一組global的陣列，存著目前已使用的字元(a~z)，之後計算時只要針對目前要加入的字串去增加或減少此陣列即可，但我好懶就沒有改了XD</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>Medium</tag>
      
      <tag>Backtracking</tag>
      
      <tag>Bit Manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 198 House Robber</title>
    <link href="/2024/01/21/20240121/"/>
    <url>/2024/01/21/20240121/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/house-robber/">題目連結</a></p><hr><h2 id="❗️-題意"><a href="#❗️-題意" class="headerlink" title="❗️ 題意"></a>❗️ 題意</h2><p>給定一個陣列 $nums$，請你從裡面竟可能的選擇總和最大的數值，並且不能夠選擇相連的數字，最後請輸出能夠從此陣列中拿到的最大值為何。</p><ul><li><p>Input: $[1,2,3,1]$</p></li><li><p>Output: $4$</p><ul><li>$nums[0] + nums[2] &#x3D; 4$</li></ul></li><li><p>Input: $[2,7,9,3,1]$</p></li><li><p>Output: $12$</p><ul><li>$nums[0] + nums[2] + nums[4] &#x3D; 12$</li></ul></li><li><p>Constraints:</p><ul><li>$1 \leq nums.length \leq 100$</li><li>$0 \leq nums[i] \leq 400$</li></ul></li></ul><hr><h2 id="✔️-題解"><a href="#✔️-題解" class="headerlink" title="✔️ 題解"></a>✔️ 題解</h2><p>首先，我們可能會很直覺的想到，是否我們只需要選擇index全部為奇數或全部為偶數加起來即可，但很明顯此方法是錯的，例如 $[10, 1, 1, 10]$ ，若只選奇數或只選偶數最大皆只有 $11$ ，但若我們拿 $nums[0]$ 與 $nums[3]$ 便可以獲得 $20$ 。<br>因此我們可以透過類似於 <a href="https://leetcode.com/problems/climbing-stairs/">Climing Stairs</a>的方法來思考此題，假設我們要選擇房子 $i$ ，則必定保證房子 $i - 2$ 房子 $i - 3$ 一定有一個被選到，因為全部的數值皆為正數，就算有那種需要橫跨數個來選的(例如橫跨四個以上，中間的 $i - 2$ 與 $i - 3$ 一定有一個也可以被選)。因此此問題就能簡化成以下式子： $dp[i] &#x3D; nums[i] + max(dp[i - 2], dp[i - 3])$<br>而在實作上，不管Top-Down或Button-Up的作法皆可以成功解決此問題。</p><hr><h2 id="💻-程式碼"><a href="#💻-程式碼" class="headerlink" title="💻 程式碼"></a>💻 程式碼</h2><ul><li><p>Top-Down(with Memoization)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 2 ms, AC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; dp;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> h, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(h &lt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> dp[h] = nums[h];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[h] != <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> dp[h];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[h] = nums[h] + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">solve</span>(h - <span class="hljs-number">2</span>, nums), <span class="hljs-built_in">solve</span>(h - <span class="hljs-number">3</span>, nums));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        n = nums.<span class="hljs-built_in">size</span>();<br>        dp.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-built_in">fill</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>(), <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">solve</span>(n - <span class="hljs-number">1</span>, nums), <span class="hljs-built_in">solve</span>(n - <span class="hljs-number">2</span>, nums));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>Button-Up</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 0ms, AC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">2</span>)&#123;<br>                nums[i] += nums[i - <span class="hljs-number">2</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                nums[i] += <span class="hljs-built_in">max</span>(nums[i - <span class="hljs-number">2</span>], nums[i - <span class="hljs-number">3</span>]);   <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[n - <span class="hljs-number">1</span>], nums[n - <span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>Runtime: 0 ms, faster than 100% of C++ online submissions</p>          </div></li></ul><hr><h2 id="類似問題：-213-House-Robber-II"><a href="#類似問題：-213-House-Robber-II" class="headerlink" title="類似問題： 213 House Robber II"></a>類似問題： <a href="https://leetcode.com/problems/house-robber-ii/">213 House Robber II</a></h2><ul><li><p>此題與 House Robber唯一的差別為其房子排序為一個環，代表第一個房子與最後一個房子也是相連的，而我們同樣可以透過類似的概念來完成此問題。</p></li><li><p>在實際上，我們可以分為兩個Cases，Case1是是不使用第一個房子，但使用最後一間(實作上直接將第一個房子設為0即可)，Case2則相反，使用第一個房子而不使用最後一間，並分別對兩個Case用上面的方法求解即可</p></li><li><p>Button-Up</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 0ms, AC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; v1 = nums;<br>        v1[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; v2 = nums;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">2</span>)&#123;<br>                v1[i] += v1[i - <span class="hljs-number">2</span>];<br>                v2[i] += v2[i - <span class="hljs-number">2</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                v1[i] += <span class="hljs-built_in">max</span>(v1[i - <span class="hljs-number">2</span>], v1[i - <span class="hljs-number">3</span>]);<br>                v2[i] += <span class="hljs-built_in">max</span>(v2[i - <span class="hljs-number">2</span>], v2[i - <span class="hljs-number">3</span>]);   <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(v1[n - <span class="hljs-number">1</span>], v1[n - <span class="hljs-number">2</span>]), <span class="hljs-built_in">max</span>(v2[n - <span class="hljs-number">2</span>], v2[n - <span class="hljs-number">3</span>]));<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>Runtime: 0 ms, faster than 100% of C++ online submissions</p>          </div></li></ul><hr><h2 id="🧠-心得"><a href="#🧠-心得" class="headerlink" title="🧠 心得"></a>🧠 心得</h2><p>這兩題真的蠻像的，第二題甚至只需要複製前一提的程式再稍微改一下即可！</p><hr>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>Medium</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1685 Sum of Absolute Differences in a Sorted Array</title>
    <link href="/2023/08/23/20230823/"/>
    <url>/2023/08/23/20230823/</url>
    
    <content type="html"><![CDATA[<h2 id="題目連結"><a href="#題目連結" class="headerlink" title="題目連結"></a><a href="https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/">題目連結</a></h2><h2 id="❗️-題意"><a href="#❗️-題意" class="headerlink" title="❗️ 題意"></a>❗️ 題意</h2><ul><li>給定一個 Non-decreasing的陣列 $nums$, 請輸出一個與原本的 nums大小相同的陣列 $results$，對於$results[i]$，其值為$nums[i]$與其他所有元素$nums[j]$的絕對值總和，如範例所示。<ul><li>Input: $[2,3,5]$</li><li>Output: $[4,3,5]$<ul><li>$4 &#x3D; |2 - 3| + |2 - 5|$</li><li>$3 &#x3D; |3 - 2| + |3 - 5|$</li><li>$5 &#x3D; |5 - 2| + |5 - 3|$</li></ul></li><li>Constraints:<ul><li>$2 \leq nums.length \leq 10^5$</li><li>$1 \leq nums[i] \leq nums[i + 1] \leq 10^4$</li></ul></li></ul></li></ul><hr><h2 id="✔️-題解"><a href="#✔️-題解" class="headerlink" title="✔️ 題解"></a>✔️ 題解</h2><p>首先，這題我們可以先想到暴力解的方式，利用兩個迴圈窮舉任兩個元素之間的絕對值再累加出答案，此種方式的時間複雜度為$O(n^2)$，對於nums的長度為$10^5$而言顯然一定會吃一個TLE。<br>因此，我們就需要利用到nums這個陣列是「已排序」的條件來解決此題目，首先我們可以觀察到一個情況，對於某個$nums[i]$來說，$num[0] \sim nums[i - 1]$都會比$nums[i]$小，相反地，對於$nums[i + 1] \sim nums[nums.length - 1]$一定都比$nums[i]$來得大，透過利用此特性，我們就可以先將$num[0] \sim nums[i - 1]$與$nums[i + 1] \sim nums[nums.length - 1]$的部分先計算出來，而答案就是比$nums[i]$還小的數值的總和減掉與其相同數量($i - 1$個)的$nums[i]$，再去加上比$nums[i]$還大的數值總和掉相同數量($nums.length - 1 - i$個)的$nums[i]$。<br>而如何快速的計算區間的總和也是一個問題，在這部分，我們可以透過前綴和(Prefix Sum)的方式，宣告一個新的陣列$prefix$，其中$prefix[i]$內存的就是$nums[0] \sim nums[i]$的總和，以此我們就能夠快速的知道比某個$nums[i]$還小的總和與比$nums[i]$還大的總和，分別為$prefix[i - 1]$與$prefix[nums.length - 1] - prefix[i]$，而對於最後的答案，我們可以分別計算兩者結果，再將其總和，以下面表示：</p><ul><li>$lesser &#x3D; nums[i] * i - prefix[i - 1]$</li><li>$greater &#x3D; (prefix[n - 1] - prefix[i]) - (n - 1 - i) * nums[i]$</li><li>$ans &#x3D; lesser + greater$</li></ul><hr><h2 id="💻-程式碼"><a href="#💻-程式碼" class="headerlink" title="💻 程式碼"></a>💻 程式碼</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TLE</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getSumAbsoluteDifferences</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                ans[i] += <span class="hljs-built_in">abs</span>(nums[i] - nums[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 70ms, AC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getSumAbsoluteDifferences</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> prefix[n];<br>        <span class="hljs-built_in">memset</span>(prefix, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(prefix));<br>        prefix[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            prefix[i] = prefix[i - <span class="hljs-number">1</span>] + nums[i];<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt;result;<br>        result.<span class="hljs-built_in">emplace_back</span>(prefix[n - <span class="hljs-number">1</span>] - prefix[<span class="hljs-number">0</span>] - (n - <span class="hljs-number">1</span>) * prefix[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> lesser = nums[i] * i - prefix[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> greater = (prefix[n - <span class="hljs-number">1</span>] - prefix[i]) - (n - <span class="hljs-number">1</span> - i) * nums[i];<br>            result.<span class="hljs-built_in">emplace_back</span>(lesser + greater);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>Runtime: 70 ms, faster than 99.11% of C++ online submissions</p>          </div><hr><h2 id="🧠-心得"><a href="#🧠-心得" class="headerlink" title="🧠 心得"></a>🧠 心得</h2><p>最近開始佛系刷LeetCode，一天大概寫3~5題左右，以後遇到有趣的題目再放上來與大家分享我的解題方法與心得啦～</p><hr>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>prefix sum</tag>
      
      <tag>Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>112 四大電資推甄心得分享</title>
    <link href="/2023/05/11/20230511/"/>
    <url>/2023/05/11/20230511/</url>
    
    <content type="html"><![CDATA[<hr><p>哈囉各位，我是輔仁大學資工四年級的Hank Hsu，因為在推甄期間受到許多人的幫助，最後也成功上了交大智能系統所，前幾天剛好受邀與系上學弟妹分享推甄心得，因此希望能發一篇文幫助未來有意願推甄的學弟妹們。</p><p>首先，我想很老實的告訴大家，推甄時除非有什麼非常與眾不同的成就或者紀錄，否則學業成績與排名其實才是最重要的，以四大作為例子，近年來除了成大外，台清交的資工系都僅需要繳交書審資料，對於四大而言，老實說私立學校可能在他們眼中都差異不大，可想而知在審資料時，成績肯定佔了非常大的一部分，不知未來是否會改回書審+面試的制度，但我認為要過這些學校書審的門檻，維持成績一定會是推甄時最重要一環。</p><p>再來就是書審的部分，我全部的資料都是用Canva做的，我個人在暑假結束時其實只完成了CV而已，剩下的內容都是在開學一直到推甄期間內我都還有再做更改，所以我認為要提早多久前完成非常困難，若想提前準備的人，可以先看前一年的推甄簡章來看，基本上要求的內容不會差異太大。而CV內容的部分，除了學歷與成績外，我還附上了自己熟悉的技術(如程式語言)與一些簡要的個人經歷(包含助教、畢業專題、各種獎項等等)，另外，我認為CPE的成績若不錯放在CV內絕對是大加分的(對於四大教授而言，我認為CPE直接代表了我們的程式能力，真的要好好準備)。</p><p>除了CV外，各學校都會需要不同的繳交資料，但不乎就是自傳，讀書計畫，各種有利資料(競賽成績、作品、社團等)，推薦信等等。因此在準備時建議大家可以先寫一個公版，再依照不同學校去調整內容。當時除了清大資工需要英文的讀書計畫外，對於不同學校我只改了對於研究領域的論述，建議各位在準備時可以先看一下自己想去的學校有哪些不同的實驗室，並在撰寫讀書計畫時寫上對於哪些研究主題感興趣(e.g. 影像處理、圖形辨識、NLP等)。而在有利資料內，除了附上各種競賽的獎狀外，比較需要注意的就是畢業專題與作品的部分，建議各位可以撰寫一到兩頁關於畢業專題的介紹，其中必須包含專題介紹，研究成果，與「個人負責」的部分，而在此部分中，盡量寫出「自己」在專題中所使用的技術與解決的問題，我認為這能非常有效的表現出自己的能力與在專題中的重要性。同樣的，若是團隊合作的課堂專題或是小專案也都能當作作品放到其他有利裡面，我自己也都是將個人在這些項目內所負責的部分與使用的技術特別標示出來。至於自傳的部分，由於我個人其實並不太會寫這種東西XD，這裡就不跟各位分享太多(怕害了你們QQ)，但大致上，我是以幾個主題慢慢寫下來，分別為，「家庭與人格特質」、「學習歷程與自我實現」、「研究領域與未來展望」，這裡供各位參考。</p><p>陸續放榜後，只有成大需要第二階段的面試，老實說我超級緊張，非常害怕被問到一些很可怕的問題，因此我還特別去爬文做了面試問題總整理，幸運的是，在面試時三位教授大部分都問了與畢業專題的內容而已(可見畢業專題的重要性)，只有一個是問我關於組合語言課堂專題的問題，但也只是問內容而已，而非實作細節(早就忘記了，笑死)。因此在面試前，大家可以將CV、作品等等整理並裝訂成一本，方便到時直接給面試的教授做參考，也可以間接引導教授問與這些有關的問題，我認為肯定比「請說明SVD分解出來的三個矩陣代表什麼意義」這種問題好回答多了XD，最後也確實正取了，只能說當時運氣真好！</p><p>最後，我想與各位分享一些我在推甄時的心得。我從剛入學就已經決定要推甄(高中時看到同學都可以用繁星上很好的學校，真心羨慕QQ，就決定大學一定要推甄)，因此三年來我都對於自己的成績非常重視(非常建議大家通識課可以留一些大四再修，有些真的非常影響學業成績)，也積極的參與校內與校外的競賽與社團。最終能夠推甄上交大，除了感謝家人、師長、學長姐、同學們一路上的幫忙外，我也非常感謝輔大給了我這些資源、讓我遇到這麼好的指導教授、遇到了能夠相互幫助的專題組員、也遇到了另一半(欸?)。因為要感謝的人太多了，不如謝天吧！</p><p>希望推甄經驗能對你們有幫助，祝福各位都能順利推甄或考試上自己理想的學校！<br>若有任何問題，也歡迎詢問我，我會盡量回答的～</p><p>以下為發在Dcard上的連結，也可以參考留言的回答的唷！<br><a href="https://www.dcard.tw/f/fju/p/241403967">https://www.dcard.tw/f/fju/p/241403967</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好久不見</title>
    <link href="/2023/02/05/20230205/"/>
    <url>/2023/02/05/20230205/</url>
    
    <content type="html"><![CDATA[<hr><p>好久不見！終於處理完研究所推甄相關的事務了，目前寒假大致上由實習(30%)+學習（30%）+耍廢(40%)組合起來：），下禮拜一定要把耍廢的比例調低一點哈哈哈。整體來說上個學期真的是大學以來心情起伏非常誇張的一個學期，但整體來說研究所申請最終的結局還算不錯！今年9月就正式成為陽明交通大學的學生囉～</p><p>至於下學期開始，我預計會修四堂碩班的課，分別是計算機視覺、與資料探勘相關的課、超啟發式演算法、機器學習。之後還要開始準備找房子了！最近因為實習的關係，我稍微學習了一些我沒碰過的技術，之後再來寫一些介紹的文章好了～</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好多事QQ</title>
    <link href="/2022/09/24/20220924/"/>
    <url>/2022/09/24/20220924/</url>
    
    <content type="html"><![CDATA[<hr><p>最近的我真的超級無敵忙，要處理推甄的事，又有助教的工作需要處理，畢業專題也在進行中，甚至還要與實習單位面試。這週的我真的有點渾身乏術的感覺，好想把一切拋得遠遠的，不想面對任何事，但這就是成長吧。<br>現在的我只能夠壓榨自己來換取更多的時間，想辦法在同時間內完成更多事，可能未來就習慣了，只是現在的我仍在適應不良的狀態，只希望未來的自己，不要辜負了現在的努力。<br>小時候的我已經逃避夠多次了，現在的我，不想也不會再逃避了，希望啦XD</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>實習面試</title>
    <link href="/2022/09/18/20220918/"/>
    <url>/2022/09/18/20220918/</url>
    
    <content type="html"><![CDATA[<hr><p>這週六我與未來的實習單位進行面試，他問了我畢業專題做了哪些部分，並用了什麼做法。老實講我當下的回答其實有一些部分講得非常卡，最後我是直接開meeting用的投影片來講，而他問的很多問題也都沒有回答到點上，我自己認為講得非常糟糕。<br>之後就聊到我有在比程式競賽，他問我最近打過最有趣的是哪一題，當下其實我的腦袋是一片空，我幾乎整個暑假都與畢業專題相處，整個暑假打的題目相較而言就少之又少，我就突然想到我的Blog好像有寫一些題目的題解，我是用Bar Codes那題，好險暑假剛好有回去重新寫一次這題，不然我就真的是完蛋了哈哈哈。<br>最後，他問我有沒有什麼問題，我問了有關於工作時間與內容、是否有需要實體meeting。對了，我問了一個很不應該的問題，現在想到還是非常慚愧，我問他你們上一個案子是在做什麼東西，問出來的當下我就後悔了，這畢竟是與他們內部有關的問題，我這樣問好像有點不太禮貌，當下我就趕緊道歉，並與面試的人員說如果有不方便不用回答沒關係，好險面試人員真的非常nice，他還是跟我說了他們上一個專案的內容。<br>這是我第一次真正面試的經驗，我真的認爲自己是不及格的。在過程中過於緊張導致回答的很卡就算了，連自己熟悉的領域都回答的非常糟糕，甚至忘了自己模型設計的某些細節，真的要哭出來了。只能說這真的是一次非常特別的經驗，至於之後是否進入這的實習單位，就只能之後再分享囉～</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心情</tag>
      
      <tag>面試</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apple Silicon在pytorch的GPU測試</title>
    <link href="/2022/09/16/20220916/"/>
    <url>/2022/09/16/20220916/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h2><p>大約在暑假的時候，Pytorch就宣布Apple Silicon的GPU將可以在做深度學習中使用，而這幾天我就稍微用了我的電腦測試一下M1 GPU對於訓練一個神經網路的效果與時間</p><h2 id="建立conda環境"><a href="#建立conda環境" class="headerlink" title="建立conda環境"></a>建立conda環境</h2><ul><li>建立與進入環境   <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda create <span class="hljs-comment">--name pytorch-with-m1 python=3.8</span><br>conda <span class="hljs-built_in">activate</span> pytorch-<span class="hljs-keyword">with</span>-m1<br></code></pre></td></tr></table></figure></li></ul><h2 id="下載pytorch-preview-version"><a href="#下載pytorch-preview-version" class="headerlink" title="下載pytorch preview version"></a>下載pytorch preview version</h2><ul><li>到pytorch<a href="https://pytorch.org/">官方網站</a>找要指令輸入複製(在Preview中)  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">pip3 install <span class="hljs-comment">--pre torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/nightly/cpu</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="確認是否能使用Apple-Silicon的GPU"><a href="#確認是否能使用Apple-Silicon的GPU" class="headerlink" title="確認是否能使用Apple Silicon的GPU"></a>確認是否能使用Apple Silicon的GPU</h2><ul><li>測試是否可以執行(若安裝成功會輸出True，tensor的device會是mps:0)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.backends.mps.is_available()<br>torch.zeros(<span class="hljs-number">1</span>).to(<span class="hljs-string">&#x27;mps&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="測試階段"><a href="#測試階段" class="headerlink" title="測試階段"></a>測試階段</h2><ul><li>說明<ul><li>我將所有random seed皆固定住，並使用辨識mnist的資料作為本次測試</li><li>只需將device設定為’mps’ 或 device設定為’cpu’ 就可以分別測試使用GPU或使用CPU所需的時間</li></ul></li><li>參數設定<ul><li>epoch: 10</li><li>optimizer: adam</li><li>learning rate: 0.001</li><li>batch size: 128</li><li>critirion: cross entropy<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> qqdm <span class="hljs-keyword">import</span> qqdm<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> os, random, numpy <span class="hljs-keyword">as</span> np<br><br>start_time = time.time()<br><br><span class="hljs-comment"># fix random seed</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;seeded&#x27;</span>)<br>seed = <span class="hljs-number">0</span><br>os.environ[<span class="hljs-string">&quot;PYTHONHASHSEED&quot;</span>] = <span class="hljs-built_in">str</span>(seed)<br>random.seed(seed)<br>np.random.seed(seed)<br>torch.manual_seed(seed)<br>torch.cuda.manual_seed(seed)<br>torch.cuda.manual_seed_all(seed)<br><br>device = <span class="hljs-string">&quot;mps&quot;</span><br>train_data = datasets.MNIST(root=<span class="hljs-string">&#x27;./data&#x27;</span>, train=<span class="hljs-literal">True</span>, transform=transforms.ToTensor(), download=<span class="hljs-literal">True</span>)<br>train_loader = DataLoader(train_data, batch_size=<span class="hljs-number">128</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Model, self).__init__()<br>        self.net = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Conv2d(<span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Flatten(),<br>            nn.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">7</span> * <span class="hljs-number">7</span>, <span class="hljs-number">10</span>),<br>            nn.Softmax(dim=<span class="hljs-number">1</span>),<br>        )<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> self.net(x)<br><br>Net = Model().to(device)<br>optimizer = torch.optim.Adam(Net.parameters(), lr=<span class="hljs-number">0.001</span>)<br>critirion = nn.CrossEntropyLoss()<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    train_loss = <span class="hljs-number">0</span><br>    progress_bar = qqdm(train_loader)<br>    <span class="hljs-keyword">for</span> (x, y) <span class="hljs-keyword">in</span> progress_bar:<br>        x = x.to(device)<br>        y = y.to(device)<br>        y_pred = Net(x)<br>        loss = critirion(y_pred, y)<br>        <br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br>        <br>        progress_bar.set_infos(&#123;<br>            <span class="hljs-string">&#x27;epoch&#x27;</span>: epoch,<br>            <span class="hljs-string">&#x27;loss&#x27;</span>: <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;loss:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>,<br>        &#125;)<br>        <br>n_correct = <span class="hljs-number">0</span><br>n_sample = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, (x, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>    x = x.to(device)<br>    y = y.to(device)<br>    out = Net(x)<br>    _, pred = torch.<span class="hljs-built_in">max</span>(out, <span class="hljs-number">1</span>)<br>    n_correct += (pred == y).<span class="hljs-built_in">sum</span>().item()<br>    n_sample += y.shape[<span class="hljs-number">0</span>]<br>acc = n_correct / n_sample<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\nAccuracy: <span class="hljs-subst">&#123;acc:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>, <span class="hljs-string">f&#x27;total time when using <span class="hljs-subst">&#123;device&#125;</span>: <span class="hljs-subst">&#123;time.time() - start_time:<span class="hljs-number">.4</span>f&#125;</span> seconds&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><ul><li>CPU: Accuracy: 0.9886 total time when using cpu: 131.9462 seconds</li><li>GPU: Accuracy: 0.9889 total time when using mps: 100.2587 seconds</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>我們可以看到，對於準確率來說，兩者相異不大，會有差別的原因可能是因為CPU與GPU對於浮點運算上可能有些誤差導致而成</li><li>就時間上來說，GPU比CPU所花的時間少了31.7秒左右，也就是是說使用GPU快了約31.6%左右，看起來並非特別明顯，可能要等之後正式版釋出後再來看pytorch有沒有再將其優化了</li><li>另外，我也做了純Linear的版本，當batch size不夠大的時候(我自己是測到大小為1024)，我發現使用CPU所花的時間會比GPU的少了許多，也就是說除非能夠將batch size設得足夠大，否則在只使用Linear時使用GPU反而拖慢了訓練時間</li></ul><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>將Apple Silicon拿來做深度學習終於不是件遙不可及的事了，且得益於Apple的GPU與CPU的RAM是共用的，因此或許可以減少在訓練時Out Of Memory發生的情況。雖然說目前我認為要調整內容應該還很多，但能夠有所進步已經是一件令人非常開心的事了。</p><div class="note note-warning">            <p>最近pytorch也宣佈將整個框架交給由AMD， AWS， Google， Meta， Microsoft，Nvidia所組成的獨立基金會來管理，或許未來AMD顯卡也適合拿來跑深度學習的日子也近了～</p>          </div><hr>]]></content>
    
    
    <categories>
      
      <category>測試</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度學習</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPC第一次社課</title>
    <link href="/2022/09/12/20220912/"/>
    <url>/2022/09/12/20220912/</url>
    
    <content type="html"><![CDATA[<hr><p>這週是開學第二周，今天我剛好是CPC第一堂課的講師，也是我這學期最後一次講課了。主題是程式競賽簡介，主要是分享一些與競賽相關的內容與個人了心路歷程，而我還是一如既往的忘記錄影了:)，真的是對學弟妹非常抱歉。其實加入CPC有三年了，對於這個社團的回憶是真的多，也是我人生中第一個認真「玩」的社團，甚至當了社長！過程中經過了很多人的幫助，我也學習到了很多。雖然目前的我對於程式競賽的熱忱對比當初下降了很多，但有時還是會刷一些題目，講解題目對我來說仍是一件有趣的事。從小到大我大部分的工作都與教學有關，雖然我個人並沒有當老師的夢想，但能夠指導學生，讓學生進步，我個人內心是開心的，或許我真的很享受傳授我的想法與知識給其他人的過程。<br>我能很自豪的說，參與CPC是我大學生活中，做過的最有意義的事！</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心情</tag>
      
      <tag>CPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>開學第一週</title>
    <link href="/2022/09/08/20220908/"/>
    <url>/2022/09/08/20220908/</url>
    
    <content type="html"><![CDATA[<hr><p>這週是開學第一週，雖說我這學期的學分比過去少了很多，但我認為反而工作量並沒有減少太多。最近又剛好遇到有學長問我是否有想要實習，是做電腦視覺那方面的，我個人其實還蠻感興趣的，但我非常擔心會因此而拖累到專題的進度，也十分害怕自己會忙不過來而導致其他事情被delay。因此我目前還在觀望，先試試看這陣子是否太忙，之後再來決定。這幾週陸續有推甄的消息出來了，而我的進度仍然還是只完成了個人簡歷，真的不知道自傳到底要寫什麼，好擔心啊。</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>測試模型中...</title>
    <link href="/2022/09/04/20220904/"/>
    <url>/2022/09/04/20220904/</url>
    
    <content type="html"><![CDATA[<hr><p>最近在測試我的模型，我使用了兩種版本，一種是利用Feature Disentanglement的方式，透過將Content與Style分開，之後再將Content image的content feature與Style image的style feature合併。第二種則是透過AdaIN，將Content image去風格化後再將style的風格加在上面。雖說兩者的概念上是類似的，但實際在寫時所用的方法差蠻多的(之後有空再來介紹AdaIN)。這週與老師meeting時老師也提到我怎麼用的方法兩週內差那麼多XD，其實是我自己不小心把第一種方法寫壞了，以為我的模型可能不適合跑大資料集(事實證明我錯了，可以看「模型train不起來」這篇)。而兩種模型跑出來有一些微妙的差異，各有好壞，但第一種模型的缺點也很明顯，有時會合成的image中會有Style image裡面特徵，而那個特徵並沒有很好的融合在圖片中，反而會使圖片看起來就像是有雜訊一樣。等之後的模型全部train完再來看一下結果如何ㄌ～</p><hr>]]></content>
    
    
    <categories>
      
      <category>學習紀錄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度學習</tag>
      
      <tag>畢業專題</tag>
      
      <tag>Autoencoder</tag>
      
      <tag>Style Transfer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新生訓練</title>
    <link href="/2022/09/02/20220902/"/>
    <url>/2022/09/02/20220902/</url>
    
    <content type="html"><![CDATA[<hr><p>今天被學生會邀請回去介紹CPC社團，原本2:20就準備要換我講了，但中間發生一些事，且中間又臨時加了理工學院院院長的介紹，我覺得院長非常健談，只用一頁投影片就講了好久哈哈哈XD。之後換到我，我就先在乙班先介紹，中間都還算順利，而到甲班後，由於我們社團的指導老師剛好是甲班班導，老師就剛好坐在後面，導致我覺得我講的綁手綁腳的。這次新生訓練讓我深深感受到，我在輔大的時間只剩下不到一年了，再過個幾年我就要出社會了，目前的我還實在不知道要如何面對這件事情，只能走一步算一步了。</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>心情</tag>
      
      <tag>CPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa10931 Parity</title>
    <link href="/2022/08/30/20220830/"/>
    <url>/2022/08/30/20220830/</url>
    
    <content type="html"><![CDATA[<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1872">題目連結</a></p><hr><ul><li>❗️ 題意<br>給定數字n，請求出n這個數字的二進位為何與它的二進位數字有幾個1</li></ul><hr><ul><li>✔️ 題解<br>我們可以直接利用模擬的方式，每次就是先看這個數字除以2的餘數為何，之後再除以2就好，在過程中當餘數為1時可以紀錄下來，就是二進位數字中共有多少一。</li></ul><hr><ul><li>💻 程式碼<blockquote><p>10ms</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> num;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; num &amp;&amp; num != <span class="hljs-number">0</span>)&#123;<br>string st;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>st += <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cnt++;<br>st +=<span class="hljs-string">&#x27;1&#x27;</span>;<br>&#125;<br>num /= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-built_in">reverse</span>(st.<span class="hljs-built_in">begin</span>(), st.<span class="hljs-built_in">end</span>());<br>cout &lt;&lt; <span class="hljs-string">&quot;The parity of &quot;</span> &lt;&lt; st &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot; (mod 2).\n&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>也可以利用python的bin來簡化程式碼<blockquote><p>10ms</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>:<br><span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;The parity of <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(num))[<span class="hljs-number">2</span>:]&#125;</span> is <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(num)).count(<span class="hljs-string">&quot;1&quot;</span>)&#125;</span> (mod 2).&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><ul><li>🧠 心得<br>自從開始做畢業專題後寫python的時間比寫c++的時間多太多了，程式語言就是個工具，不同場合需要使用的語言本來就不同，對我來說c++多半是拿來解題較多，而其他時間多是使用python。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>UVa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>binary</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa10721 Bar Codes</title>
    <link href="/2022/08/28/20220828/"/>
    <url>/2022/08/28/20220828/</url>
    
    <content type="html"><![CDATA[<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1662">題目連結</a></p><hr><ul><li>❗️ 題意<br>bar codes是由黑色與白色的線組合而成，給定n, k, m，分別代表共有n條線，k個bar(分為黑色區域與白色區域，且必定黑白相間，一開始為黑色區域)，每個bar最多由m條線組成，請求給定條件下的所有可能數量。</li></ul><hr><ul><li>✔️ 題解<br>再開始題解前，我可以先來思考一個問題</li><li>舉個例子：假設我們有無限個1元、2元、3元的硬幣，共有幾種方法可以組合出5元?<ul><li>Ans:5(11111, 1112, 113, 122, 23)</li></ul></li><li>但其實我們可以透過轉換這個問題為求可能的方法數，變成$(1+x+x^2+x^3+x^4+x^5+..)(1+x^2+x^4+..)(1+x^3+x^6+..)&#x3D;a_0+a_1x+a_2x^2+…$的解中$x^5$的係數。且由於三個括號中只要x的次方大於5就不會影響到$x^5$的答案，因此我們可以省略成$(1+x+x^2+x^3+x^4+x^5)(1+x^2+x^4)(1+x^3)&#x3D;a_0+a_1x+a_2x^2+…$，而這個多項式$x^5$的係數為5，也與我們的答案是一樣的。(<a href="https://stat.nuk.edu.tw/cbme/discrete/disc_math/ch4.pdf">更多詳細內容可以參考這裡</a>)</li><li>生成函數到底與這題有什麼關係呢？其實我們可以想像區間其實就是上面例子中的無限個1元，而最高次其實就是m，並且由於我們的區間至少要有一個，所以並沒有常數項。因此此題就變成了：<br>$(x+x^2+x^3+..+x^m)^k &#x3D; a_0x^k+a_1x^{k+1}+a_2x^{k+2}+..$在$x^n$的係數為何?我們還可以將x項提出來，變成$x^k(1+x+x^2+..+x^{m - 1})^k &#x3D; x^k(a_0+a_1x+a_2x^2+…)$，並左右同除以$x^k$，最後就得到了$(1+x+x^2+..+x^{m - 1})^k &#x3D; (a_0+a_1x+a_2x^2+…)$，而我們就變成求$x^{n-k}$的係數了。</li></ul><hr><ul><li>💻 程式碼<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function">vector&lt;LL&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;LL&gt; v, vector&lt;LL&gt; base)</span></span>&#123;<br><span class="hljs-function">vector&lt;LL&gt; <span class="hljs-title">ans</span><span class="hljs-params">((<span class="hljs-type">int</span>)v.size() + (<span class="hljs-type">int</span>)base.size() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>(); i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-type">int</span>)base.<span class="hljs-built_in">size</span>(); j++)&#123;<br>ans[i + j] += v[i] * base[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n, k, m;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; k &gt;&gt; m)&#123;<br><span class="hljs-keyword">if</span>(k * m &lt; n || n &lt; k)&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>vector&lt;LL&gt;<span class="hljs-built_in">v</span>(m, <span class="hljs-number">1</span>);<br>vector&lt;LL&gt;<span class="hljs-built_in">base</span>(m, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++)&#123;<br>v = <span class="hljs-built_in">mul</span>(v, base);<br>&#125;<br>cout &lt;&lt; v[n - k] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>當bar的最長線條數乘以bar的數量小於線條的數量或者線條的數量小於bar的數量都是0</p>          </div></li></ul><hr><ul><li>🧠 心得<br>這題大部分的做法都是利用DP的方式來做，連老師介紹這題時也是利用DP。但有一位非常厲害的同學給了給了利用生成函數的想法(在此請收下我的膝蓋🧎‍♂️)，而我也應證了此想法是正確的。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>UVa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>Generating Function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型train不起來</title>
    <link href="/2022/08/25/20220825/"/>
    <url>/2022/08/25/20220825/</url>
    
    <content type="html"><![CDATA[<hr><p>這禮拜算是遇到了一些低潮，由於資源實在不太夠了，目前我一個人所使用GPU的ram至少需要36G左右，又加上我是一次跑很多個小模型(不同風格需要分開train)，目前的GPU是兩張3090，仍然不夠我們用，只能Deep Learning真的都是用錢燒出來的哈哈哈哈。<br>而另一點是我找到了一個5000張content與5000張style的dataset，我的模型對於還原content與style雖然有些模糊，但還算可以接受，至於他們所組合出來的合成照就是灰灰的一片，目前我認為可能有兩種原因，第一種純粹是還沒train完(大約只跑了2%左右)，再來就是我的模型餐數量太少了，沒有辦法完全學習好。我自己還不知道要怎麼解決。我個人是傾向第二種，因此只好先想辦法再拿更小的資料集來印證我的想法。最近也會盡量多找一些paper來看，希望能找到一些修改上的靈感。</p><hr>]]></content>
    
    
    <categories>
      
      <category>學習紀錄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>深度學習</tag>
      
      <tag>畢業專題</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CycleGAN</title>
    <link href="/2022/08/23/20220823/"/>
    <url>/2022/08/23/20220823/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="CycleGAN"><a href="#CycleGAN" class="headerlink" title="CycleGAN"></a><a href="https://arxiv.org/pdf/1703.10593.pdf">CycleGAN</a></h1><p><img src="/./img/20220823/first_page.png"></p><hr><h2 id="📝-背景知識"><a href="#📝-背景知識" class="headerlink" title="📝 背景知識"></a>📝 背景知識</h2><ul><li>Generative Adversarial Networks</li></ul><hr><h2 id="❗️-Introduction"><a href="#❗️-Introduction" class="headerlink" title="❗️ Introduction"></a>❗️ Introduction</h2><p>成對的資料是非常難以搜集的(有點像監督式學習的方式，可以參考pix2pix)，而CycleGAN只需要兩個domain的資料(例如一群馬的data與一群斑馬的data)，就可以完成兩個domain內的互相轉換，這不僅降低了資料搜集的難度，也增廣了能應用的層面。<br><img src="/./img/20220823/pair.png" alt="paired data v.s unpaired data"></p><hr><h2 id="🏆-Goal"><a href="#🏆-Goal" class="headerlink" title="🏆 Goal"></a>🏆 Goal</h2><ul><li>Generator<ul><li>我們以馬與斑馬作為例子，假設他們的資料及分別稱為$X$與$Y$，那我們要做的事情就是訓練兩個Generator$G$與$F$，我們希望 $X$經過 $G$後盡可能與$Y$越像越好，且$Y$經過$F$後也要可能與$X$越像越好。寫成數學一點就是$G(x)\approx y$，且$F(y)\approx x$ ($x \in X$ and $y \in Y$)。</li></ul></li><li>Discriminator<ul><li>要如何衡量生成器的好壞，就輪到我們的Discriminator出場啦，我們一樣有兩個Discrminator $D_X$與$D_Y$，分別是判斷$F(y)$與$x$是否足夠相似與$G(x)$與$y$是否足夠相似，其實就有點像是在train一個classifier的感覺，因此整體的架構如下：</li><li><img src="/./img/20220823/structure.png" alt="架構"></li></ul></li><li>Loss Function<ul><li>Adversarial Loss<ul><li>$\mathcal{L}_{GAN}(G, D_Y, X, Y) &#x3D; \mathbb{E} _{p \sim data(y)}[\log (D_Y(y))] + \mathbb{E} _{p \sim data(x)}[\log (1 - D_Y(G(x)))] $</li><li>我們以$G$(使x mapping to y)與$D_Y$(分辨$G(x)$與$y$)作為例子，這個loss的主要功用就是讓最的$G(x)$與$y$越像好，對於Generator來說，我們會希望去minimize這個loss，而Discrminator則是相反，希望去maximize這個loss，對於$F$與$D_X$也是一樣的。</li></ul></li><li>Cycle Consistency Loss<ul><li>$\mathcal{L}_{cyc}(G, F) &#x3D; \mathbb{E} _{p \sim data(x)}[||F(G(x)) - x||_1] + \mathbb{E} _{p \sim data(y)}[||G(F(y)) - y||_1]$</li><li>單單只有Adversarial Loss是無法讓整個model有好效果的，因為我們無法確定$x$與$G(x)$是否足夠類似，因此我們需要利用來回映射(以馬為例子就是：馬➡️斑馬➡️馬)，也就是希望讓$x$與$F(G(x))$越像越好。<div class="note note-warning">            <p>作者在論文中有提到，相較起來L1的效果是最好的</p>          </div></li></ul></li><li>Identity Loss(optional)<ul><li>$\mathcal{L}_{identity}(G, F) &#x3D; \mathbb{E} _{p \sim data(y)}[||G(y) - y||_1] + \mathbb{E} _{p \sim data(x)}[||F(x) - x||_1]$</li><li>這個loss作者只簡單地提及了一下，但它也是一個非常重要的loss。我們知道$G$是用來生成斑馬的Generator，因此若我們將斑馬$y$丟進這個Generator後，出來的結果也應該是斑馬，因此這個loss就是在最小化這件事。<div class="note note-danger">            <p>當初我在報這篇論文給教授聽時報告錯這個部分，真尷尬：）</p>          </div></li></ul></li></ul></li></ul><hr><h2 id="🍎-Result"><a href="#🍎-Result" class="headerlink" title="🍎 Result"></a>🍎 Result</h2><p><img src="/./img/20220823/result.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa00524 Prime Ring Problem</title>
    <link href="/2022/08/21/20220821/"/>
    <url>/2022/08/21/20220821/</url>
    
    <content type="html"><![CDATA[<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=465">題目連結</a></p><hr><ul><li>❗️ 題意<br>給定數字n，代表利用1~n的數字圍成一個環，並以1當成出發點，連續的數字加起來一定要是質數(包括最後一個數字與1)，請輸出所以可能的組合。</li></ul><hr><ul><li>✔️ 題解<br>很明顯這題就是枚舉，我們只先建出一個質數表，只要建到31即可(n最大16，其中最大的質數就是15+16&#x3D;31)，我們再利用backtracking的方式，維護一個vector，當目前的最後一個與要新加入的數字和為質數時就將其加入，並在當vector的長度為n時，確認最後一個與第一個數字的和是否是質數，再決定是否是合法的序列。<br>其中，我們可以注意到，因為我們組出來的序列一定會是「奇偶奇偶奇偶奇偶…」，若n是奇數時，最後一個數字一定也會是奇數，結尾的奇數(至少3)加開頭的1一定是一個大於2的偶數，而大於2的偶數都不是質數，也就是說我們沒有辦法組合出任何一個序列，因此當n是奇數時是沒有答案的。</li></ul><hr><ul><li>💻 程式碼<blockquote><p>160ms</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">prime_table</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">35</span>, <span class="hljs-literal">true</span>)</span></span>;<br>p[<span class="hljs-number">0</span>] = p[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">35</span>; i++)&#123;<br><span class="hljs-keyword">if</span>(p[i])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * i; j &lt; <span class="hljs-number">35</span>; j += i)&#123;<br>p[j] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-type">bool</span> used[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> n;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>vector&lt;<span class="hljs-type">bool</span>&gt;p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(v.<span class="hljs-built_in">size</span>() == n &amp;&amp; p[v.<span class="hljs-built_in">back</span>() + <span class="hljs-number">1</span>])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)<br>cout &lt;&lt; v[i];<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; v[i];<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br><span class="hljs-keyword">if</span>(!used[i])&#123;<br><span class="hljs-keyword">if</span>(p[v[v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] + i])&#123;<br>v.<span class="hljs-built_in">emplace_back</span>(i);<br>used[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>();<br>v.<span class="hljs-built_in">pop_back</span>();<br>used[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>p = <span class="hljs-built_in">prime_table</span>();<br><span class="hljs-type">int</span> kase = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; n)&#123;<br><span class="hljs-built_in">memset</span>(used, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(used));<br>v.<span class="hljs-built_in">clear</span>();<br>v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>);<br>used[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(kase)<br>cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Case &quot;</span> &lt;&lt; ++kase &lt;&lt; <span class="hljs-string">&quot;:\n&quot;</span>;<br><span class="hljs-keyword">if</span>((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">dfs</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>在題目上沒提到連續兩個case間要換行🤔</p>          </div></li></ul><hr><ul><li>🧠 心得<br>昨天社團請了外部講師來講數論這個主題，講到後來我真的差點瘋了，後半部分真的完全聽不懂，有一半時間都在看著投影片發呆，剛好我又坐在最前面，超級尷尬的。高中時我一直自認為數學還不錯，上了大學後才發現自己的數學其實根本就不太好QQ，要多加油了～</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>UVa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>Backtracking</tag>
      
      <tag>Prime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你現在過得好嗎</title>
    <link href="/2022/08/20/20220820/"/>
    <url>/2022/08/20/20220820/</url>
    
    <content type="html"><![CDATA[<hr><p>Juby是曾經我家養的一隻狗狗，是我最好的家人跟朋友，它在去年的8月19號凌晨離開我了，那天也剛好是我去比私立大專院校程式競賽的日子。其實在他過世的前幾天我就有感覺他準備要離開我們了，完全不吃飯，一直拉肚子，連站起來的力氣都幾乎沒了。我能感受到，他應該也非常的害怕，我只能抱著他，安慰他，讓他知道我永遠都會在他的身邊。</p><p>Juby過世的當下，是我第一次感受到如此的心痛與不捨，彷彿我的心也在當下支離破脆的一般。從到過世到現在，已經過了一年了，我仍會回憶起Juby還在時的場景，想起他陪伴我的每個瞬間，想起他的一舉一動是如何讓人好氣又好笑。而如今的我，只能看著過去的照片，想像著他還在我們的身邊。</p><p>不知道Juby你現在，過得還好嗎？<br>我們都很想你，真的很想你。</p><table><thead><tr><th align="center">狗鄙視</th><th align="center">me &amp; Juby</th><th align="center">Juby伸懶腰</th></tr></thead><tbody><tr><td align="center"><img src="/./img/20220820/1.png"></td><td align="center"><img src="/./img/20220820/2.png"></td><td align="center"><img src="/./img/20220820/3.jpeg"></td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>父親節快樂</title>
    <link href="/2022/08/18/20220818/"/>
    <url>/2022/08/18/20220818/</url>
    
    <content type="html"><![CDATA[<hr><p>我爸是一間小公司的老闆，說是老闆，其實大部分的事情也都是我爸一個人在處理，包括接案子時要的任何單據，全部都是他用一台將近10年前，開word會當機的電腦一個鍵一個鍵打出來的。對我來說，我覺得蠻簡單的東西，我爸卻要花超過10倍的時間才能處理好，甚至忙到半夜三四點才睡，早上六點就又出門上班了。<br>昨天晚上，我與我媽一起去挑了一台新的筆電給我爸爸，我也把他平常會用的工具都準備在電腦裡面，給他當成父親節禮物。我爸收到時表面上看起來並沒有特別的情緒起伏，但我想他心中是開心的。<br>老實說我已經有好多年沒有跟爸爸說過父親節快樂了，對於過父親節這整件事對我來說非常尷尬。<br>總而言之，祝您父親節快樂，爸爸! </p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa01001 Say Cheese</title>
    <link href="/2022/08/15/20220815/"/>
    <url>/2022/08/15/20220815/</url>
    
    <content type="html"><![CDATA[<hr><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3442">題目連結</a></p><hr><ul><li>❗️ 題意<br>在一塊起司中，給有n個球形的洞，在洞裡的移動不耗時間，再給定出發點與終點，問你從出發點到終點，的最短路徑(距離：時間 &#x3D; 1:10)是多少?</li></ul><hr><ul><li>✔️ 題解<br>將起點與終點的半徑設為0(變成半徑為0的球)，再將所有球的考慮過半徑的距離算出來，做一次Floyd Warshall就可找出起點到終點的最短路徑(時間)。<br>假設有點A與點B，A(x)代表A的座標在x，r則是其半徑，我們可以分成以下三個case來討論：<br>|            Case1:兩圓外離         |           Case2:兩圓外切          |           Case3:兩圓相交          |</li></ul><p>:————————-:|:————————-:|:————————-:<br><img src="/./img/20220815/case1.png">  |  <img src="/./img/20220815/case2.png">  |  <img src="/./img/20220815/case3.png"></p><h2 id="因此，我們可以導出以下式子-distance-a-b-x3D-begin-cases-overline-AB-r-a-r-b-amp-text-if-overline-AB-gt-r-a-r-b-0-amp-text-if-overline-AB-le-r-a-r-b-end-cases-建完圖後這題就變成單純的最短路啦，我們只要利用floyd-warshall或任何求最短路的演算法，找出起點與終點的距離再乘以10就是答案了。"><a href="#因此，我們可以導出以下式子-distance-a-b-x3D-begin-cases-overline-AB-r-a-r-b-amp-text-if-overline-AB-gt-r-a-r-b-0-amp-text-if-overline-AB-le-r-a-r-b-end-cases-建完圖後這題就變成單純的最短路啦，我們只要利用floyd-warshall或任何求最短路的演算法，找出起點與終點的距離再乘以10就是答案了。" class="headerlink" title="因此，我們可以導出以下式子$$distance(a, b) &#x3D;\begin{cases}\overline{AB} - r_{a} - r_{b}, &amp; \text{if $\overline{AB}$ &gt; $r_{a}$ + $r_{b}$} \\0, &amp; \text{if $\overline{AB}$ $\le$  $r_{a}$ + $r_{b}$}\end{cases}$$建完圖後這題就變成單純的最短路啦，我們只要利用floyd warshall或任何求最短路的演算法，找出起點與終點的距離再乘以10就是答案了。"></a>因此，我們可以導出以下式子<br>$$<br>distance(a, b) &#x3D;<br>\begin{cases}<br>\overline{AB} - r_{a} - r_{b}, &amp; \text{if $\overline{AB}$ &gt; $r_{a}$ + $r_{b}$} \\<br>0, &amp; \text{if $\overline{AB}$ $\le$  $r_{a}$ + $r_{b}$}<br>\end{cases}<br>$$<br>建完圖後這題就變成單純的最短路啦，我們只要利用floyd warshall或任何求最短路的演算法，找出起點與終點的距離再乘以10就是答案了。</h2><ul><li>💻 程式碼<blockquote><p>10ms</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis_cal</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> z1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> z2)</span></span>&#123;<br><span class="hljs-type">double</span> x = x1 - x2, y = y1 - y2, z = z1 - z2;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(x * x + y * y + z * z);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">holes</span>&#123;<br><span class="hljs-type">int</span> x, y, z, r;<br>&#125;;<br><br>holes arr[<span class="hljs-number">105</span>];<br><span class="hljs-type">double</span> dis[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> kase = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>cin &gt;&gt; arr[i].x &gt;&gt; arr[i].y &gt;&gt; arr[i].z &gt;&gt; arr[i].r;<br>&#125;<br><span class="hljs-comment">// 起點與終點可以視為半徑=0的洞</span><br>cin &gt;&gt; arr[<span class="hljs-number">0</span>].x &gt;&gt; arr[<span class="hljs-number">0</span>].y &gt;&gt; arr[<span class="hljs-number">0</span>].z;<br>arr[<span class="hljs-number">0</span>].r = <span class="hljs-number">0</span>;<br>cin &gt;&gt; arr[n + <span class="hljs-number">1</span>].x &gt;&gt; arr[n + <span class="hljs-number">1</span>].y &gt;&gt; arr[n + <span class="hljs-number">1</span>].z;<br>arr[n + <span class="hljs-number">1</span>].r = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n + <span class="hljs-number">2</span>; j++)&#123;<br>dis[i][j] = INT_MAX;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 利用公式，紀錄任兩點的距離。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n + <span class="hljs-number">2</span>; j++)&#123;<br><span class="hljs-type">double</span> d = <span class="hljs-built_in">dis_cal</span>(arr[i].x, arr[i].y, arr[i].z, arr[j].x, arr[j].y, arr[j].z);<br><span class="hljs-keyword">if</span>(d &lt;= arr[i].r + arr[j].r)<br>dis[i][j] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span>&#123;<br>dis[i][j] = d - arr[i].r - arr[j].r;<br>&#125;<br><br>&#125;<br>&#125;<br><span class="hljs-comment">// floyd warshall</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n + <span class="hljs-number">2</span>; k++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n + <span class="hljs-number">2</span>; j++)&#123;<br>dis[i][j] = <span class="hljs-built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cheese %d: Travel time = %d sec\n&quot;</span>, ++kase, (<span class="hljs-type">int</span>)<span class="hljs-built_in">round</span>(dis[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>] * <span class="hljs-number">10</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>答案記得乘以10後做round，否則會有精度問題QQ</p>          </div></li></ul><hr><ul><li>🧠 心得<br>記得這是某次我們學校自辦賽的題目，當初做完這題的時候一直WA，找不到自己哪裡寫錯了，想說是哪裡想法有錯，最後被精度搞了一波🥲。<br>賽後發現自己的想法是正確的，只差在取round的部分，就想在這邊分享給大家啦～</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>UVa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Graph</tag>
      
      <tag>cpp</tag>
      
      <tag>Floyd Warshall</tag>
      
      <tag>Shortest Path</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa00452 Project Scheduling</title>
    <link href="/2022/08/13/20220813/"/>
    <url>/2022/08/13/20220813/</url>
    
    <content type="html"><![CDATA[<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=393">題目連結</a></p><hr><ul><li>❗️ 題意<br>給定點、經過這個點的cost、哪些點連到這個點，求出需要多少時間才能夠走完所有點。</li></ul><hr><ul><li>✔️ 題解<br>ans[now]代表目前這個點的答案，而ans[next]是now這個點所可以走到的點，而更新公式就是ans[next] &#x3D; max(ans[next], node[next] + ans[now])，其中node是原本點上的值。<br>我們只需要在利用BFS做拓墣排序的過程中更新ans的值，就能夠確定點的更新順序是對的，不會有更新點的時候前面的點還沒有更新到的問題，最後只需要輸出最大的ans[i]即可。</li></ul><hr><ul><li>💻 程式碼<blockquote><p>140ms</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> node[MAXN];<br><span class="hljs-type">int</span> cnt[MAXN];<br><span class="hljs-type">int</span> ans[MAXN];<br><span class="hljs-type">bool</span> used[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt;G[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(node, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(node));<br><span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br><span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(ans));<br><span class="hljs-built_in">memset</span>(used, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(used));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXN; i++)&#123;<br>G[i].<span class="hljs-built_in">clear</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> t;<br>string line;<br>cin &gt;&gt; t;<br>cin.<span class="hljs-built_in">ignore</span>();<br><span class="hljs-built_in">getline</span>(cin, line);<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>line.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">getline</span>(cin, line);<br><span class="hljs-keyword">if</span>(line.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br><span class="hljs-type">char</span> idx, another;<br><span class="hljs-type">int</span> val;<br>ss &gt;&gt; idx;<br>ss &gt;&gt; val;<br>node[idx - <span class="hljs-string">&#x27;A&#x27;</span>] = val;<br>ans[idx - <span class="hljs-string">&#x27;A&#x27;</span>] = val;<br>used[idx - <span class="hljs-string">&#x27;A&#x27;</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(ss &gt;&gt; another)&#123;<br>cnt[idx - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>G[another - <span class="hljs-string">&#x27;A&#x27;</span>].<span class="hljs-built_in">emplace_back</span>(idx - <span class="hljs-string">&#x27;A&#x27;</span>);<br>&#125;<br>&#125;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXN; i++)&#123;<br><span class="hljs-keyword">if</span>(cnt[i] == <span class="hljs-number">0</span> &amp;&amp; used[i])&#123;<br>q.<span class="hljs-built_in">emplace</span>(i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> now = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> next: G[now])&#123;<br>ans[next] = <span class="hljs-built_in">max</span>(ans[next], node[next] + ans[now]);<br>cnt[next]--;<br><span class="hljs-keyword">if</span>(cnt[next] == <span class="hljs-number">0</span>)&#123;<br>q.<span class="hljs-built_in">emplace</span>(next);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXN; i++)&#123;<br>res = <span class="hljs-built_in">max</span>(res, ans[i]);<br>&#125;<br>cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">if</span>(t)&#123;<br>cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>這題更煩的反而是格式輸入輸出吧…😅</p>          </div></li></ul><hr><ul><li>🧠 心得<br>當初會解這題是因為剛好有學長來問我類似的題目，也趁這次機會來複習一下拓墣排序。之前的我都是用DFS的順序來找order，而改用queue的方法只需要用一個array來記錄入in degree即可，比我用DFS的做法好寫很多。<br>順帶一提，學長說這是他們進碩班老師拿給他們練習的大一題目，大一就在拓墣排序，沒搞錯吧？</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>UVa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Topological Sort</tag>
      
      <tag>AOE Network</tag>
      
      <tag>Graph</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>忘記要報告了QQ</title>
    <link href="/2022/08/11/20220811/"/>
    <url>/2022/08/11/20220811/</url>
    
    <content type="html"><![CDATA[<hr><p>又到了每週一次的meeting，由於上禮拜沒有meeting到，我以為這週是不用報告的，只要大略講一下這週的進度，就沒有做投影片了。誰知道原來上週我們這組沒有報告到，我就緊急的在其他同學報告的時候把投影片趕出來(只做了7頁)，只能說我真的做的很敷衍哈哈哈。我發現自己常常會有這種僥倖的心態，常常把事情拖到最後一刻才做，我想這點是我需要好好反省並改善的，這幾天我應該會開始做我研究所的讀書計畫，也要開始寄信給老師詢問推薦信的事了，現在只希望一切順利！</p><blockquote><p>30分鐘趕出來的投影片<br><img src="/./img/20220811/20220811.png" alt="敷衍ㄉ投影片"></p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心情</tag>
      
      <tag>畢業專題</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型修改</title>
    <link href="/2022/08/10/20220810/"/>
    <url>/2022/08/10/20220810/</url>
    
    <content type="html"><![CDATA[<hr><p>這個星期我稍微修改了模型的架構，聽從了學長的建議，只轉單一風格或許會讓NN學不到「風格」的特徵，因此我應該更注重的是在多種風格的轉換而非單純的多張照片對一種風格的轉換。另外，我也稍微看了一下adain的論文，既然風格轉換可以說是從一個domain映射到另一個domain，那對於最後要生成圖像的decoder(Generator)，就不應該對它做IN(instance normalization)，有關於adain我想我未來可以再發一篇文來解釋。而都是基於理論上的想法，而我在實作時明顯發現，刪掉了IN會讓我的loss能夠將的更低，但由於訓練時間因為要做多風格轉換就從原本的幾個小時變成了需要訓練一天半左右。</p><p>目前訓練上最麻煩的就是時間了，因為每個禮拜都要meeting，但礙於訓練時間拉長的緣故，其實我進度可能會稍微緩慢一些，更何況這還只是對於小資料集(10張照片轉換成8種風格)，未來若要做到更大的資料集，我想那個訓練時間應該會非常可觀QQ，目前也只能這樣了。</p><blockquote><p>未來我在想，應該要增加我的發文頻率，由於我原本預期是週記，但我發現一週能講的事情實在是太多了，而且我是個非常健忘的人，常常一週過了我就忘記我這週到底都在幹嘛了哈哈哈哈，未來我希望能夠一週發個4~5篇文，最好是能每天都更新，不然到最後我怕因為懶惰而放棄我的週記計畫QQ。</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>學習紀錄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度學習</tag>
      
      <tag>畢業專題</tag>
      
      <tag>Autoencoder</tag>
      
      <tag>Style Transfer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七夕情人節快樂</title>
    <link href="/2022/08/08/20220808/"/>
    <url>/2022/08/08/20220808/</url>
    
    <content type="html"><![CDATA[<hr><p>上週四剛好是七夕情人節，而那天我也決定到新竹的清華大學走走(抱歉ㄌ教授，沒有開到每週一次的meeting)，順便看一下他們校園內的設備之類的。雖然沒有辦法進入他們的資工系大樓內，但依然可以看出他們的設備與輔大的差別，光是圖書館就足以讓人羨慕不已(雖然資工學生應該也不會去圖書館啦哈哈哈)，而這也讓我更想上好一點的研究所，卻也因此更加擔憂，害怕自己推甄沒有辦法上。</p><p>這幾天我也在查詢各校資工系的簡章，也開始著手準備自己的履歷。我認為自己的經歷並不豐富，而目前專題也沒有辦法做出一個好的成果，真的只能加油ㄌQQ。</p><p>順帶一提，這週也剛好找到新社長了！未來我就是CPC的退休老人啦，學弟妹加油ㄌ &gt;&lt;</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的吉娃娃著火了</title>
    <link href="/2022/08/03/20220803/"/>
    <url>/2022/08/03/20220803/</url>
    
    <content type="html"><![CDATA[<hr><p>目前我畢業專題研究的主題是Style Transfer，而Style Transfer簡單來說就是將相片A轉換成相片B的風格(曾經被女友說過就是IG特效，差點哭出來QQ)，能使用的方法其實蠻多元的，也不限於使用NN(neural network)來做。而我的整體架構是利用autoencoder的概念，想法算是蠻簡單的，就是將兩張照片的內容與風格抽出來後再合併，比較難的是要如何<strong>「衡量」</strong>一張照片的風格究竟是什麼，對於從小到大都沒有藝術細胞的我來說這真的是非常痛苦的一件事。<br>目前為止整體轉換的效果其實還蠻普通的，可能還需要再調整一下網路架構與想法，下面是我最近做出來的成果，分別是轉變幅度從小到大，而內容都是吉娃娃加上火焰的樣子。</p><table><thead><tr><th align="center">small</th><th align="center">medium</th><th align="center">large</th></tr></thead><tbody><tr><td align="center"><img src="/./img/20220803/small3.png"></td><td align="center"><img src="/./img/20220803/medium3.png"></td><td align="center"><img src="/./img/20220803/large3.png"></td></tr></tbody></table><p>我個人認為中間那張轉換的幅度是最剛好的，而我也試過拿其他風格來轉換，只能說轉換成火焰是一個較為簡單的task，如果是其他風格的話目前我的模型還沒有辦法跑出比較好的結果，只能等調整過再分享給大家。</p><blockquote><p>對了，我的文章下方有開啟留言板，若有建議或任何問題在底下留言，之後再發一篇文來介紹一下我自己好了～</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>學習紀錄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度學習</tag>
      
      <tag>畢業專題</tag>
      
      <tag>Autoencoder</tag>
      
      <tag>Style Transfer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>週記計畫</title>
    <link href="/2022/08/01/20220801/"/>
    <url>/2022/08/01/20220801/</url>
    
    <content type="html"><![CDATA[<hr><p>我是輔大資工要升大四的學生，今天是8月的第一天，也是我開始寫週記的第一週，希望我能夠持續維持記錄生活的習慣。<br>基本上我的週記會包含我的生活與一些心情跟最近在做的事。至於為何要開始寫週記呢，其實我還沒有一個特別好的說法，就只是單純想試試看而已。</p><hr>]]></content>
    
    
    <categories>
      
      <category>週記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>廢話</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
